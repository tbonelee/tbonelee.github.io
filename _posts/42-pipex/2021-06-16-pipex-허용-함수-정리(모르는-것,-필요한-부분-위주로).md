---
layout: post
title: "pipex 허용 함수 정리(모르는 것, 필요한 부분 위주로)"
date: "2021-06-16 14:24:59 +0900"
categories:
  - 42-pipex
---
#### open 함수


- \#include \<fcntl.h\>
- 늘 써오던대로
- 파이프 라인의 끝에 명시한 파일이 없는 경우 생성하므로
 기존에 쓰던 플래그에 더해서 O\_CREAT플래그를 사용해야할 것
 같다.
- error발생시 \-1 반환


#### close 함수


- \#include \<unistd.h\>
- 파일 디스크립터 넘겨주면 fd table에서 descriptor 삭제.
- open과 맞물려서 사용
- fork() 호출시 부모 프로세스와 자식 프로세스 간 파일
 디스크립터 테이블 동일하므로 같은 파일에 대해 같은 fd를
 가짐. 그렇지만 이는 복사본이므로 한쪽 프로세스에서
 close(fd)를 하는 경우에 다른 프로세스에서 닫히지는 않는다.


#### read 함수


- \#include \<unistd.h\> or \<sys/types.h\> or
 \<sys/uio.h\>
- 읽은 만큼 반환, 그 후 eof 만나면 0 반환, 오류시 \-1 반환


#### write 함수


- \#include \<unistd.h\>
- 쓴 바이트만큼 반환. 오류 나면 \-1 반환.


#### waitpid 함수



[https://codingdog.tistory.com/entry/%EB%A6%AC%EB%88%85%EC%8A%A4\-waitpid\-%ED%95%A8%EC%88%98\-%EC%9E%90%EC%8B%9D\-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EB%A5%BC\-%EA%B8%B0%EB%8B%A4%EB%A6%B0%EB%8B%A4](https://codingdog.tistory.com/entry/%EB%A6%AC%EB%88%85%EC%8A%A4-waitpid-%ED%95%A8%EC%88%98-%EC%9E%90%EC%8B%9D-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EB%A5%BC-%EA%B8%B0%EB%8B%A4%EB%A6%B0%EB%8B%A4)




[리눅스 waitpid 함수 : 자식 프로세스를 기다린다.
 



  리눅스에서 wait와 waitpid는 프로세스의 종료
 상태를 리턴해 주는 함수입니다. pid\_t waitpid(pid\_t
 pid,int \*statloc,int options);  성공을 하면,
 프로세스 ID를, 오류가 발생하면 \-1을, 그 외의 경우에는
 0\..
 



 codingdog.tistory.com](https://codingdog.tistory.com/entry/%EB%A6%AC%EB%88%85%EC%8A%A4-waitpid-%ED%95%A8%EC%88%98-%EC%9E%90%EC%8B%9D-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EB%A5%BC-%EA%B8%B0%EB%8B%A4%EB%A6%B0%EB%8B%A4)


<https://blockdmask.tistory.com/23>




[\[UNIX] 시그널(Signal) 기본설명 및 함수
 



 Unix에서 사용하는 Signal에 대해 알아보겠습니다.
 (Linux도 동일하려나.. 어짜피 조상은 같고 커널에서
 제공하는 시스템 콜이니까..) 1\. 시그널(Signal) 이란? :
 Signal이란 Software interrupt로, process에 무..
 



 blockdmask.tistory.com](https://blockdmask.tistory.com/23)


<https://reakwon.tistory.com/105>




[\[리눅스] 프로세스 상태 얻어오기 (wait, waitpid 함수 )
 



 wait, waitpid 함수는 아래의 header파일을
 include해야합니다. 이 두 함수는 부모프로세스가
 자식프로세스를 기다리는 공통점이 있습니다만 waitpid는
 어떤 자식을 기다릴지 조금 더 구체적으로 지정할
 



 reakwon.tistory.com](https://reakwon.tistory.com/105)

- \#include \<sys/wait.h\>
- 인수로 주어진 pid의 자식 프로세스가 종료되거나, 시그널
 함수 호출하는 신호 전달될 때까지 호출한 자리에서 일시
 중지.
- pid\_t waitpid(pid\_t pid, int \*stat\_loc, int options);
- \*stat\_loc에 자식 프로세스 종료 상태를 저장. 이는 매크로를
 통해 비교해서 확인 가능
- 자식 프로세스 종료시 자식 프로세스의 pid 반환. 오류시 \-1
 반환. WNOHANG옵션이 있는데 자식 프로세스가 종료되지
 않았다면 바로 0을 반환.


#### wait 함수


- \#include \<sys/wait.h\>
- waitpid가 특정 pid의 자식 프로세스를 기다리는 반면(옵션에
 따라 달라질 수 있긴 함), wait은 임의의 자식 프로세스를
 대기.
- wait(\&status)는 waitpid(\-1 \&status, 0\)을 호출한
 것과 동일.


#### pipe 함수


- \#include \<unistd.h\>
- int pipe(int fildes\[2]);
- 파이프를 생성하여 fildes에 파이프에 대한 fd값을 할당.
- write end인 fildes\[1]에 쓰여진 내용은 read end인
 fildes\[0]을 통해 읽을 수 있다.
- dup2를 이용해서 stdout이 write end를 향하게 하고 stdin이
 read end를 향하게 하는 방식으로 파이프 구현 가능


#### dup 함수


- \#include \<unistd.h\>
- int dup(int fildes);
- 인자로 전달받은 파일 서술자 복제하여 반환. 가능한 가장
 낮은 서술자를 돌려준다고 함.
- 오류시 \-1 반환


#### dup2 함수


- \#include \<unistd.h\>
- int dup2(int fd, int fd2\);
- fd의 파일 서술자를 복사하여 fd2에도 부여. fd가 가리키는
 파일을 fd2도 가리키도록.
- 오류시 \-1 반환


#### execve 함수


- \#include \<unistd.h\>
- int execve(const char \*path, char \*const argv\[], char
 \*const envp\[]);
- execve함수를 호출한 프로세스를 새 프로세스로 바꿔준다.
- 새 프로세스는 **path**변수로 지정되는 파일을 이용하여
 실행된다.
- **argv**는 '널종료되는 캐릭터 스트링(일반적인
 c스트링)'을 가리키는 캐릭터 포인터들의 배열이다. 이 포인터
 배열은 널종료된다(널포인터 끝에 찍어주기?). 새 프로세스가
 사용하게 될 인자들의 목록이 된다. 최소 한 개의 인자가
 존재해야 하며 첫번째 인자는 실행 파일의 이름이 되어야
 한다.(path변수의 끝에 있는 단어?).
- **envp**도 **argv**와 같은 타입의 널종료되는
 포인터 배열. 여기에 들어갈 배열에 대한 포인터는 보통
 전역변수 **environ**에 저장된다. 보통 envp는
 실행되는 커맨드에 대한 직접적인 인자가 아닌 정보들을
 넘겨준다.
- 호출하는 프로세스 이미지에서 열려 있는 fd는 새 프로세스
 이미지에서도 동일하게 열려있게 된다.
 (close\-on\-exec플래그를 준 경우에는 예외)
- 그 외에 상속하는 내용은 'man 2 execve' 참조


#### fork 함수


- \#include \<unistd.h\>
- pid\_t fork(void);
- 함수를 호출하는 프로세스를 정확히 복사한 프로젝트를 생성.
- 자식 프로세스는 부모 프로세스 ID와 다른 고유한 프로세스
 ID를 갖는다.
- 자식 프로세스는 부모 프로세스의 파일 디스크립터를 복사한
 파일 디스크립터를 가진다. 따라서 fork직후 동일한 파일
 디스크립터는 동일한 객체를 가리키므로 한 프로세스에서
 lseek등의 사용은 다른 프로세스가 read등을 사용할 때 다른
 결과가 나오게 할 수 있다.
- 복사한 파일 디스크립터 테이블은 프로세스마다 고유하므로 한
 프로세스에서 파일 디스크립터를 변경해도 다른 프로세스의
 파일 디스크립터 테이블에 영향을 주지는 않는다.
- 에러시 \-1 반환


#### perror 함수


- \#include \<stdio.h\>
- void perror(const char \*s);
- 전역변수 **errno**의 현재 값에 대응되는 에러메시지를
 표준에러로 출력해준다(개행문자 포함).
- 인자로 들어온 스트링이 널포인터이거나 널문자를 가리키고
 있는 경우 바로 에러메시지가 출력된다. 그렇지 않다면 인자로
 들어온 스트링을 출력한 후 콜론을 출력, 그 다음에 에러
 메시지가 출력된다.


#### strerror 함수


- \#include \<string.h\>
- char \*strerror(int errnum);
- errnum에 해당하는 스트링을 가리키는 포인터를 반환한다.
- errnum이 식별이 안 되는 경우 "Unkonwn error: 인자값"의
 스트링을 반환한다.


#### exit 함수


- \#include \<stdlib.h\>
- void exit(int status);
- 프로세스를 종료하는 함수.
- 프로세스 종료전에 다음 순서대로 작업을 수행한다. 1\)
 atexit(3\)함수에 등록된 함수를 등록된 순서의 역순으로 호출.
 2\) 열려있는 모든 출력 스트림을 플러시 3\) 모든 열려있는
 스트림을 닫는다. 4\) tmpfile(3\) 함수로 생성된 모든 파일을
 unlink한다.
- C99 표준은 0, EXIT\_SUCCESS, EXIT\_FAILURE를 status로 가능한
 값으로 설정해놓았다. 다른 값도 사용 가능.
