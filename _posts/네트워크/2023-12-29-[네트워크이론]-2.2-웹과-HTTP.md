---
layout: post
title: "[네트워크이론] 2.2 웹과 HTTP"
date: "2023-12-29 22:20:02 +0900"
categories:
  - 네트워크
---
(Computer Networking a top\-down Approach 7th 내용입니다)
 


## HTTP 개요


### HTTP: HyperText Transfer Protocol


- 웹의 애플리케이션 계층 프로토콜
- 클라이언트/서버 모델 :
	- **클라이언트** : 웹 객체를 요청하고
	 받아서 보여주는 주체
	- **서버** : 요청에 맞게 웹 객체를 보내주는
	 주체
	 ### TCP 사용
- 클라이언트가 서버에 TCP 커넥션을 init
- 서버가 TCP 커넥션을 수락
- 둘 사이에 HTTP 메시지(애플리케이션 계층 프로토콜 메시지)를
 교환
- TCP 커넥션 closed
 ### Stateless
- 기본적으로 서버는 클라이언트의 지난 요청에 대한 정보를
 유지하지 않는다


## Non\-persistent HTTP / Persistent HTTP


### Non\-persistent HTTP


1. TCP 커넥션 연결
2. 커넥션 통해 기껏해야 한 개의 객체 전달
3. 커넥션 종료
 ### Persistent HTTP
4. TCP 커넥션 연결
5. 여러 개의 객체 전달 가능
6. 커넥션 종료


### Round\-Trip Time(RTT)


- 클라이언트에서 출발한 패킷이 서버를 겨처서 클라이언트에
 다시 돌아오기까지 걸리는 시간


### Non\-persistent HTTP의 response time


- TCP 커넥션 요청 이후 커넥션 응답까지의 시간 \= 1 RTT
- 파일 요청 이후 파일 응답까지의 시간 \= 1 RTT \+ 파일 전송
 시간  
\=\> Non\-persistent HTTP에서 웹 객체 응답 시간
 \= (2RTT \+ 파일 전송 시간)/(1객체)


### Non\-persistent HTTP의 이슈


- 객체 하나당 2 RTT 필요
- TCP 커넥션 당 OS 오버헤드 존재
- 브라우저가 객체를 병렬로 받기 위해 여러 개의 TCP 커넥션을
 열어놓기도 함


### Persistent HTTP (HTTP1\.1\)


- 서버가 응답 이후에도 커넥션을 유지(일정 시간 사용되지
 않으면 종료)
- 이어지는 HTTP 메시지는 해당 커넥션으로 전달
- 클라이언트는 객체에 대한 참조를 보면 바로 서버에 요청
- 같은 서버에 대해 1RTT만 소모됨 (소요되는 시간이 거의 절반)


## HTTP 메시지 포맷


### HTTP 요청 메시지


- ASCII (human\-readable format)
- example
 
```False
GET /index.html HTTP/1.1\r\n
Host: www-net.cs.umass.edu\r\n
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:80.0) Gecko/20100101 Firefox/80.0 \r\n
Accept: text/html,application/xhtml+xml\r\n
Accept-Language: en-us,en;q=0.5\r\n
Accept-Encoding: gzip,deflate\r\n
Connection: keep-alive\r\n
\r\n
```

 1\) 첫째 줄 : request line (GET, POST, HEAD, etc.)  
2\)
 나머지는 헤더 라인  
3\) 줄 처음에 Carriage return, Line
 Feed가 오면 헤더 라인의 끝을 의미
- 일반화
 
```False
method space URL space 버전 cr lf
헤더필드명 헤더값 cr lf
...
헤더필드명 헤더값 cr lf
cr lf
엔티티 바디
```

### HTTP 응답 메시지
- example
 
```False
HTTP/1.1 200 OK\r\n
Date: Tue, 08 Sep 2020 00:53:20 GMT\r\n
Server: Apache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips PHP/7.4.9 mod_perl/2.0.11 Perl/v5.16.3\r\n
Last-Modified\r\n
ETag: "a5b-52d015789ee9e"\r\n
Accept-Ranges: bytes\r\n
Content-Length: 2651\r\n
Content-Type: text/html; charset=UTF-8\r\n
\r\n
data data data ...
```

 1\) 첫째 줄 status line(protocol, status code, status
 phrase)  
2\) 나머지는 헤더 라인  
3\) 줄 처음에
 CRLF가 오면 헤더 라인의 끝을 의미


## 유저/서버 state 유지: 쿠키


- HTTP 프로토콜은 기본적으로 stateless
- 쿠키는 네 가지 컴포넌트로 구성  

 1\) HTTP 응답 메시지의 쿠키 헤더  

 2\) HTTP 요청 메시지의 쿠키 헤더  

 3\) 유저의 브라우저가 관리하는 유저 호스트에 저장된 쿠키
 파일  

 4\) 웹 사이트의 백엔드 데이터베이스
- 사용 예시
	- Authorization
	- 쇼핑 바구니
	- 추천
	- 유저 세션 state (웹 이메일)


## 웹 캐싱


- 목표 : 오리진 서버를 거치지 않고 클라이언트의 요청에 응답
- 브라우저가 웹 캐새를 향하도록 설정
- 브라우저는 모든 HTTP 요청을 캐시로 보냄
	- 캐시에 객체가 있으면 캐시가 응답
	- 없으면 오리진 서버에 캐시 서버가 요청해서 받은 것을
	 클라이언트에 전달
- 웹 캐시는 클라이언트/서버 역할 둘 다 수행
- 서버는 응답 헤더를 통해 허용 가능한 캐싱 기한을 알려준다
- 캐시의 사용 목적?
	- 클라이언트 요청에 대한 응답 시간 줄이기
	- 기관 액세스 링크에 대한 트래픽 줄이기
	 ### 예시
- 시나리오 :
	- 액세스 링크 rate : 1\.54Mbps
	- 기관 라우터에서 서버 사이의 RTT : 2 Sec
	- 웹 오브젝트 사이즈 : 100K bits
