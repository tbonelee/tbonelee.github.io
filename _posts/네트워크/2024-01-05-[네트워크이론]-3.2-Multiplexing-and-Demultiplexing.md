---
layout: post
title: "[네트워크이론] 3.2 Multiplexing and Demultiplexing"
date: "2024-01-05 01:09:25 +0900"
categories:
  - 네트워크
---
(Computer Networking a top\-down Approach 책의 내용입니다)
 


- 프로세스는 한 개 이상의 **소켓**을 가질 수
 있음
	- 네트워크는 이를 통해 프로세스와 데이터를 주고 받음
- 모든 소켓은 유일한 식별자를 가짐
	- 식별자 포맷은 UDP인지 TCP인지에 따라 조금 다르다
- 수신 측 트랜스포트 계층은 메시지를 전달해야 하는 수신
 소켓을 식별하기 위해 segment의 필드를 확인함
	- 트랜스포트 계층 segment 데이터를 적절한 소켓으로
	 전달하는 작업을
	 **역다중화(demultiplexing)** 라고 함
- 송신 측 트랜스포트 계층은 소켓에서 데이터를 모아 각
 chunk에 헤더 정보(역다중화에 사용됨)를 붙여서 캡슐화하고
 네트워크 계층올 전달
	- **다중화(multiplexing)** 라고 함
- 각 segment는
 **출발지 포트 번호 필드**(16비트),
 **목적지 포트 번호 필드**(16비트)를 헤더에
 가지고 있다.
	- 이를 소켓 식별에 활용
- 여기서는 인터넷 트랜스포트 계층의
 multiplexing/demultiplexing을 살펴보지만 실질적으로는 모든
 계층에서 일어나는 작업
 ## Connectionless Multiplexing and Demultiplexing


 파이썬으로 UDP 소켓을 생성하려면 다음과 같이 코드를 작성
 
```False
clientSocket = socket(AF_INET, SOCK_DGRAM)
```

 이렇게만 하면 트랜스포트 계층에서 1024\-65535 중 현재 UDP로
 사용되고 있지 않은 포트 번호를 자동 할당



 만약 명시적으로 포트 번호를 지정하고 싶다면 추가로 다음
 코드를 작성(ex. 19157\)
 



```False
clientSocket.bind(('', 19157))
```

예시를 통해 multiplexing/demultiplexing을 살펴보자



 UDP 포트 19157을 가진 호스트 A의 프로세스가 UDP 포트 46428을
 가진 호스트 B의 프로세스에 애플리케이션 데이터 chunk 하나를
 보내고 싶다고 가정
 


- 호스트 A의 트랜스포트 계층에서 애플리케이션 데이터, 출발
 포트 번호(19157\), 목적 포트 번호(46428\), 두 개의 다른
 값(나중에 배우게 됨)을 포함하고 있는 segment를 생성하여
 네트워크 계층으로 전달
- 네트워크 계층은 segment를 IP datagram으로 캡슐화하여 송신
 호스트 전달을 위해 "best\-effort" 시도를 한다.
- 만약 segment가 호스트 B에 도착한다면 트랜스포트 계층은
 segment에서 목적지 포트 번호(46428\)를 파악하고 포트
 46428로 식별되는 소켓으로 segment를 전달한다.



 UDP 소켓은 (destination IP address, destination port
 number)의 2\-tuple로 식별됨
 


- 두 개의 서로 다른 UDP segment가 source IP address, source
 port number가 동일하지 않더라도 동일한
 *destination IP address*와
 *destination port number*를 가지고 있으면 동일한
 프로세스의 동일한 소켓으로 전달된다.
- source port number는 return 주소의 용도로 사용됨


## Connection\-Oriented Multiplexing and Demultiplexing


- TCP 서버 애플리케이션은 "welcoming socket"을
 통해 bind한 포트에서 TCP 클라이언트로부터의
 connection\-establishment 요청을 대기
- TCP 클라이언트는 소켓을 생성하고 connection\-establishment
 요청을 보낸다. 파이썬 코드로 작성하면 다음과 같다.
 
```False
clientSocket = socket(AF_INET, SOCK_STREAM)
clientSocket.connect((serverName, serverPort))
```
- connection\-establishment 요청은 단지 destination port
 번호와 특수한 connection\-establishment bit가 TCP 헤더에
 설정된 TCP segment일 뿐이다. segment는 클라이언트가 선택한
 source port 번호도 포함하고 있다.
- 서버 프로세스를 가동 중인 호스트 운영체제가 커넥션 요청
 segment를 받으면 segment에 설정된 destination port에서
 커넥션 accept를 대기 중인 서버 프로세스를 찾는다. 그러면
 해당 서버 프로세스는 새 소켓을 생성한다.
 
```False
connectionSocket, addr = serverSocket.accept()
```
- 서버의 트랜스포트 계층은 커넥션 요청 segment에서 (1\)
 segment의 source port, (2\) source host의 IP 주소, (3\)
 segment의 destination port, (4\) destination IP 주소를
 추출하고, 이를 새 소켓의 식별자로 사용한다.
	- 앞으로 source port, source IP 주소, destination port,
	 destination IP 주소가 식별자와 일치하는 TCP segment는
	 이 소켓으로 전달되게 된다.



 TCP 소켓은 (source IP address, source port, destination IP
 address, destination port)를 모두 사용하여 식별됨
 


- 두 개의 서로 다른 TCP segment가 동일한 destination IP
 address, destination port number를 가지고 있더라도
 *source IP address*,
 *source destination port number* 중 하나라도 다르면
 다른 소켓으로 전달된다.




---
