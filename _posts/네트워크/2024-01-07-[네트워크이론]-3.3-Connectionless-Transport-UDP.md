---
layout: post
title: "[네트워크이론] 3.3 Connectionless Transport: UDP"
date: "2024-01-07 00:15:30 +0900"
categories:
  - 네트워크
---
(Computer Networking a top\-down Approach 책의 내용입니다)
 


- UDP가 IP에 더해서 하는 일은 multiplexing/demultiplexing,
 에러 체크 두 가지뿐
- UDP는 *connectionless*
- DNS가 UDP를 사용하는 프로토콜의 예시
- UDP가 TCP보다 유리한 점


	- RTT delay를 더할 수 있는 커넥션 수립이 없음
	- 커넥션 state가 없음(TCP의 신뢰적인 데이터 전송, 혼잡
	 제어에 사용됨)
	- 더 작은 헤더 사이즈
	- 혼잡 제어가 없음(빠르게 제한 없이 데이터를 보낼 수
	 있음)
- UDP가 사용되는 곳


	- 멀티미디어 스트리밍 애플리케이션 (손실 감내 가능하고
	 속도에 민감한 서비스)
	- DNS
	- SNMP
	- HTTP/3
- HTTP/3와 같이 UDP에서 신뢰적인 데이터 전송이 필요하면
 


	- 애플리케이션 계층에서 신뢰성을 더해주기
	- 애플리케이션 계층에서 혼잡 제어해주기 (공유지의 비극을
	 막기 위해)
	 ## 3\.3\.1 UDP segment 구조
- UDP 헤더는 2바이트의 네 개 필드로만 이루어짐(32 bits)
 


	- source port number
	- destination port number
	- length (UDP segment 전체 길이)
	- checksum (for checking errors)


## 3\.3\.2 UDP Checksum


- UDP 송신측은 segment의 모든 16비트 단위 word들을 더한 후
 1의 보수를 계산해서 checksum 필드로 사용한다
	- sum을 구할 때 오버플로우 값은 wrap around : 가장 낮은
	 자릿수(가장 오른쪽)의 bit에 더해줌
- (실제로는 IP 헤더의 정보 일부를 계산에 사용하지만 설명의
 편의를 위해 이는 생략)


ex)



```False
0110011001100000
0101010101010101
1000111100001100
```

의 16비트 워드 세 개가 있다고 가정


앞의 두 개 합은,



```False
0110011001100000
0101010101010101
----------------
1011101110110101
```

마지막 워드와 더하면



```False
1011101110110101
1000111100001100
----------------
0100101011000010  // 오버플로우는 wrapped around
```

1의 보수를 구하면,



```False
1011010100111101
```


 송신 측에서는 네 개의 모든 16비트 워드를 더한다(checksum도
 같이)  
checksum을 나머지 sum의 1의 보수로 설정했기
 때문에 모두 더하면 `1111111111111111`가 되어야
 한다.  
만약 0인 비트가 존재하면 패킷에 에러가 존재한다고
 판단 가능.
 


- 많은 링크 계층 프로토콜이 에러 체크를 해줌에도 UDP에서
 checksum을 제공하는 이유
	- 모든 링크 계층 프로토콜이 에러 체크를 한다는 보장이
	 없기 때문
	- 또한 링크 사이에서 segment가 정확하게 전달되더라도
	 라우터 메모리에 segment가 저장될 때 비트 에러가 발생할
	 수 있음
	- 시스템 디자인의
	 **end\-end principle** \[Saltzer 1984]
		- 몇몇 애플리케이션 기능(error detection, reliable
		 transfer)들은 *end\-end basis*로 제공해야 함
